/**
 * File Upload API routes with production AI processing
 */

import express from 'express'
import multer from 'multer'
import { db } from '../lib/db.js'
import { storageService } from '../lib/storageService.js'
import { fileProcessingJobService } from '../lib/fileProcessingJobService.js'
import path from 'path'

const router = express.Router()

// Configure multer for file uploads
const storage = multer.memoryStorage()
const upload = multer({
  storage,
  limits: {
    fileSize: 25 * 1024 * 1024, // 25MB limit for high-quality scans
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = [
      'application/pdf',
      'image/jpeg',
      'image/png',
      'image/jpg',
      'image/webp',
      'text/csv',
      'application/vnd.ms-excel',
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    ]
    
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true)
    } else {
      cb(new Error('Invalid file type. Only PDF, images, CSV, and Excel files are allowed.'))
    }
  }
})

// POST /api/upload/po-file - Upload PO file with AI processing
router.post('/po-file', upload.single('file'), async (req, res) => {
  try {
    const merchant = await db.getCurrentMerchant()
    if (!merchant) {
      return res.status(401).json({
        success: false,
        error: 'Merchant not found'
      })
    }

    if (!req.file) {
      return res.status(400).json({
        success: false,
        error: 'No file uploaded'
      })
    }

    const { 
      autoProcess = 'true', 
      supplierId,
      confidenceThreshold,
      customRules 
    } = req.body
    
    // Generate upload ID
    const uploadId = `upload_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    
    // Prepare file data for processing
    const fileData = {
      uploadId,
      fileName: req.file.originalname,
      fileSize: req.file.size,
      mimeType: req.file.mimetype,
      merchantId: merchant.id,
      supplierId: supplierId || null,
      buffer: req.file.buffer
    }

    // Get merchant AI settings
    const aiSettings = await db.client.aiSettings.findUnique({
      where: { merchantId: merchant.id }
    })

    const processingOptions = {
      autoProcess: autoProcess === 'true',
      aiSettings: {
        ...aiSettings,
        confidenceThreshold: confidenceThreshold ? parseFloat(confidenceThreshold) : aiSettings?.confidenceThreshold || 0.8,
        customRules: customRules ? JSON.parse(customRules) : aiSettings?.customRules || []
      }
    }

    // Queue file for processing
    if (processingOptions.autoProcess) {
      try {
        await fileProcessingJobService.addFileProcessingJob(uploadId, fileData, processingOptions)
        console.log(`File queued for processing: ${uploadId}`)
      } catch (jobError) {
        console.error(`Failed to queue processing job: ${uploadId}`, jobError)
        // Continue with upload success, but processing will fail
      }
    }

    // Store basic upload info for status tracking
    global.uploadStorage = global.uploadStorage || {}
    global.uploadStorage[uploadId] = {
      ...fileData,
      status: processingOptions.autoProcess ? 'processing' : 'uploaded',
      uploadedAt: new Date(),
      processingOptions
    }

    res.json({
      success: true,
      data: {
        uploadId,
        fileName: req.file.originalname,
        fileSize: req.file.size,
        status: processingOptions.autoProcess ? 'processing' : 'uploaded',
        estimatedProcessingTime: this.estimateProcessingTime(req.file.size, req.file.mimetype)
      },
      message: processingOptions.autoProcess ? 
        'File uploaded successfully and queued for AI processing' : 
        'File uploaded successfully'
    })

  } catch (error) {
    console.error('Upload error:', error)
    
    if (error.code === 'LIMIT_FILE_SIZE') {
      return res.status(400).json({
        success: false,
        error: 'File too large. Maximum size is 25MB'
      })
    }
    
    if (error.message.includes('Invalid file type')) {
      return res.status(400).json({
        success: false,
        error: error.message
      })
    }
    
    res.status(500).json({
      success: false,
      error: 'File upload failed',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    })
  }
})

// GET /api/upload/:uploadId/status - Get upload and processing status
router.get('/:uploadId/status', async (req, res) => {
  try {
    const merchant = await db.getCurrentMerchant()
    if (!merchant) {
      return res.status(401).json({
        success: false,
        error: 'Merchant not found'
      })
    }

    const { uploadId } = req.params
    
    // Check job queue status first
    const jobStatus = await fileProcessingJobService.getJobStatus(uploadId)
    
    // Check temporary storage for upload info
    global.uploadStorage = global.uploadStorage || {}
    const upload = global.uploadStorage[uploadId]
    
    if (!upload || upload.merchantId !== merchant.id) {
      return res.status(404).json({
        success: false,
        error: 'Upload not found'
      })
    }

    // Check database for completed processing results
    let purchaseOrder = null
    if (jobStatus.status === 'completed' && jobStatus.result?.purchaseOrder) {
      try {
        purchaseOrder = await db.client.purchaseOrder.findFirst({
          where: {
            id: jobStatus.result.purchaseOrder.id,
            merchantId: merchant.id
          },
          include: {
            lineItems: true,
            supplier: true
          }
        })
      } catch (error) {
        console.error('Error fetching processed PO:', error)
      }
    }

    const response = {
      uploadId,
      fileName: upload.fileName,
      fileSize: upload.fileSize,
      uploadedAt: upload.uploadedAt,
      status: jobStatus.status || upload.status,
      progress: jobStatus.progress || 0,
      message: jobStatus.message || 'Upload completed',
      processingTime: jobStatus.result?.processingTime,
      confidence: jobStatus.result?.confidence,
      purchaseOrder: purchaseOrder,
      error: jobStatus.error
    }

    res.json({
      success: true,
      data: response
    })
    
  } catch (error) {
    console.error('Get upload status error:', error)
    res.status(500).json({
      success: false,
      error: 'Failed to get upload status'
    })
  }
})

// POST /api/upload/:uploadId/process - Manually trigger processing
router.post('/:uploadId/process', async (req, res) => {
  try {
    const merchant = await db.getCurrentMerchant()
    if (!merchant) {
      return res.status(401).json({
        success: false,
        error: 'Merchant not found'
      })
    }

    const { uploadId } = req.params
    const { confidenceThreshold, customRules } = req.body
    
    // Check if upload exists
    global.uploadStorage = global.uploadStorage || {}
    const upload = global.uploadStorage[uploadId]
    
    if (!upload || upload.merchantId !== merchant.id) {
      return res.status(404).json({
        success: false,
        error: 'Upload not found'
      })
    }

    // Check if already processing
    const existingJobStatus = await fileProcessingJobService.getJobStatus(uploadId)
    if (existingJobStatus.status === 'active' || existingJobStatus.status === 'waiting') {
      return res.status(409).json({
        success: false,
        error: 'File is already being processed'
      })
    }

    // Get merchant AI settings
    const aiSettings = await db.client.aiSettings.findUnique({
      where: { merchantId: merchant.id }
    })

    const processingOptions = {
      autoProcess: true,
      aiSettings: {
        ...aiSettings,
        confidenceThreshold: confidenceThreshold || aiSettings?.confidenceThreshold || 0.8,
        customRules: customRules || aiSettings?.customRules || []
      }
    }

    // Queue for processing
    await fileProcessingJobService.addFileProcessingJob(uploadId, upload, processingOptions)
    
    // Update storage status
    upload.status = 'processing'

    res.json({
      success: true,
      message: 'File queued for processing',
      data: {
        uploadId,
        status: 'processing',
        estimatedTime: estimateProcessingTime(upload.fileSize, upload.mimeType)
      }
    })

  } catch (error) {
    console.error('Manual processing trigger error:', error)
    res.status(500).json({
      success: false,
      error: 'Failed to start processing'
    })
  }
})

// Helper function to estimate processing time
function estimateProcessingTime(fileSize, mimeType) {
  // Base processing times in seconds
  const baseTimes = {
    'application/pdf': 15,
    'image/jpeg': 20,
    'image/png': 20,
    'image/jpg': 20,
    'image/webp': 22,
    'text/csv': 5,
    'application/vnd.ms-excel': 8,
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': 8
  }

  const baseTime = baseTimes[mimeType] || 15
  
  // Adjust for file size (MB)
  const sizeMB = fileSize / (1024 * 1024)
  const sizeMultiplier = Math.max(1, sizeMB / 5) // Add time for larger files
  
  return Math.round(baseTime * sizeMultiplier)
}

export default router